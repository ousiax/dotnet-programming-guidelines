{"./":{"url":"./","title":"1 命名规范","keywords":"","body":"本章描述了一般的命名规范，包括如何使用大小写，如何为标识符选择恰当的名字，以及如何使用某些特定的术语。本章还为名字空间、类型、成员、参数、程序集、版本号以及 JSON 的命名提供了具体的规范。 1.1 大小写规范 1.1.1 标志符的大小写规则 为了区分一个标识符的多个单词，把标识符中的每个单词的首字母大写。不要用下划线来区分单词，或者在标识符中的任何地方使用下划线（私有字段采用 _camelCasing 风格）。有两种合适的方法来大写标志符中的字母： PascalCasing camelCasing PascalCasing 约定被用于除了参数名之外的所有标识符，它把标识符中每个单词的首字母（包括长度为两个字符以上的首字母缩写词）大写，如下面的例子所示： PropertyDescriptor HtmlTag 两个字母长的首字母缩写词是一个特例，在这种情况下两个字母都要大写，如下面的标识符所示： IOStream cameCasing 约定仅用于参数的名字，它把标识符中除了第一个单词之外的所有单词的首字母大写，如下面的例子所示。在例子中，如果 camelCasing 风格的标识符以两个字母长的首字母缩写词开始，那么这个缩写词都要小写。 propertyDescriptor ioStream htmlTag 下面是一些用于标识符的基本大小写规范。 ✓ DO 要把 PascalCasing 用于由多个单词构成的名字空间、类型以及成员的名字。 ✓ DO 要把 camelCasing 用于参数的名字。 表 1-1 不同类型的标识符的大小写规则 标识符 大小写 样例 名字空间 Pascal namespace System.Security { ... } 类型 Pascal public class StreamReader { ... } 接口 Pascal public interface IEnumerable { ... } 方法 Pascal public virtual string ToString(); 属性 Pascal public int Length { get; } 事件 Pascal public event EventHandler Exited; 字段（静态） Pascal puglic static readonly TimeSpan InfiniteTimeout; 枚举值 Pascal File Mode { Append, ...} 参数 Camel public static int ToInt32(string value); 1.1.2 首字母缩写词的大小写 一般来说，避免在标识符的名字中使用首字母缩写词是很重要的，除非他们是普遍使用的，能够立刻被使用的人所理解。例如，HTML、XML 和 IO 很容易理解，但不怎么常用的首字母缩写词绝对应该避免。 注：首字母缩写词（acronyms）与单词缩写（abbreviations）是有区别的，绝对不应该在标识符中使用单词缩写。首字母缩写词是由一个短语的首字母组成的，而单词缩写则仅仅把一个单词的长度变短。 从定义上讲，首字母缩写词必须至少有两个字母。由三个或以上的字母组成的首字母缩写词遵循与任何其他单词一样的规范，只有第一个字母大写，除非是 camelCasing 风格的参数名称中的第一个单词，在这种情况下第一个单词全部小写。例如： public void StartIO(Stream ioStream, bool closeIOStream); public void ProcessHtmlTag(string htmlTag); ✓ DO 要把两个字母的首字母缩写词全部大写，除非它是 camelCasing 风格的参数的第一个单词。 System.IO public void StartIO(Stream ioStream); ✓ DO 要把由三个或者三个以上字母组成的首字母缩写词的第一个字母大写。只有第一个字母大写，除非首字母缩写词是 camelCasing 风格的标识符的第一个单词。 System.Xml public void ProcessHtmlTag(string htmlTag) X DO NOT 不要把 camelCasing 风格的标识符头部的任何首字母缩写词的任何字母大写，无论首字母缩写词的长度是多少。 1.1.3 复合词和常用术语的大小写 在涉及大小写时，大多数复合词术语要作为单个单词处理。 X DO NOT 不要把所谓闭合形式的复合词中的每个单词的首字母大写。 这些复合词要写成一个单词，比如 endpoint。为了统一大小写规范，我们把闭合形式的复合词作为一个单词处理。 表 1-2 常用的复合词和常用术语的大小写及拼写 Pascal Camel Not BitFlag bitFlag Bitflag Callback callback CallBack Canceled canceled Cancelled DoNot doNot Dont Email email EMail Endpoint endpoint EndPoint FileName fileName Filename Gridline gridline GridLine Hashtable hashtable HashTable Id id ID Indexes indexes Indices LogOff logOff LogOut LogOn logOn LogIn Metadata metadata MetaData, metaData Multipanel multiplanel MultiPanel Multiview multiview MultiView Namespace namespace NameSpace Ok ok OK Pi pi PI SignIn signIn SignOn SignOut signOut signOff UserName userName Username WhiteSpace whiteSpace WhiteSpace Writable writable Writeable 有两个常用的其他术语，它们本身属于另一个类别，因为它们是俚语性质的常用缩写。这两个单词是 Ok 和 Id (它们的大小写应该如显示的那样），虽然前面的规范说过名字不应该使用缩写，但它们是例外。 1.2 通用命名规范 本节描述了一些通用的命名约束，它们涉及到单词的选择、单词缩写和首字母缩写词的使用规范以及如何避免使用编程语言特有的名字。 1.2.1 单词的选择 标识符的名字要一目了然，应该清楚地说明每个成员做什么，以及每个类型和参数表示什么。为此，名字的意思清楚要比长度短更重要。 ✓ DO 要为标识符选择易于阅读的名字。 例如，一个名为 HorizontalAlignment 的属性就比 AlignmentHorizontal 更容易阅读。 ✓ DO 要更看重可读性，而不是更看重简短性。属性名 CanScrollHorizontally 要胜过 ScrollableX （不太明显地引用到了 X 坐标轴）。 X DO NOT 不要使用下划线、连字符以及其他任何既非字母也非数字的字符。 X DO NOT 不要使用匈牙利命名法。 X AVOID 避免使用与广泛使用的编程语言的关键字有冲突的标识符。如 C# 中的 @ 符号等。 1.2.2 使用单词缩写和首字母缩写 X DO NOT 不要使用缩写词和缩约词（如 won't 是 will not 的缩约词）作为标识符的一部分。例如，要用 GetWindow，而不要用 GetWin。 X DO NOT 不要使用未被广泛接受的首字母缩写词，即使是被广泛接受的首字母缩写词，也只应该在必须的时候才使用。 1.2.3 避免使用语言特有的名字 对那些所谓的基本类型，CLR 平台上的编程语言通常都有自己的名称（别名）来称呼它们。例如 int 是 C# 中 System.Int32 的别名。 ✓ DO 要给类型名使用语义上有意义的名字，而不要使用语言特有的关键字。 例如，GetLength 这个名字比 GetInt 要好。 ✓ DO 要使用 CLR 的通用类型名，而不要使用语言特有的别名——如果除了类型之外，标识符没有其他的语义。 例如，一个把类型转换为 System.Int64 的方法应该被命名为 ToInt64，而不是 ToLong。 表 1-3 语言特有的类型名及对应的 CLR 类型名 C# Visual Basic C++ CLR sbyte SByte char SByte byte Byte unsigned char Byte short Short short Int16 ushort UInt16 unsigned short UInt16 int Integer int Int32 uint UInt32 unsigned int UInt32 long Long __int64 Int64 ulong UInt64 unsigned __int64 UInt64 float Single float Single double Double double Double bool Boolean bool Boolean char Char wchar_t Char string String String String object Object Object Object ✓ DO 要使用常见的名字，比如 value 或 item，而不要重复类型的名字——如果除了类型之外，标识符没有其他的语义，而且参数的类型不重要。 下面是一个很好的例子，类提供的这些方法可以把各种不同的数据类型写入流中： void Write(double value); void Write(float value); void Write(short value); 1.2.4 为已有 API 的新版本命名 ✓ DO 要在创建已有 API 的新版本时使用与旧 API 相似的名字。 这有助于突出 API 之间的关系。 class AppDomain { [Obsolete(\"AppDomain.SetCachePath has been deprecated. Please use AppDomainSetup.CachePath instead.\")] public void SetCachePath(string path) { ... } } class AppDomainSetup { public string CachePath { get { ... } set { ... } } } ✓ DO 要优先使用后缀而不是前缀来表示已有 API 的新版本。 这有助于在浏览文档或使用 Intellisense 时发现新版本。由于大多数浏览器和 Intellisense 按字母的顺序显示标识符，因此旧 API 与新 API 在位置上会非常接近。 ✓ CONSIDER 考虑使用全新但有意义的标识符，而不是简单地给已有标识符添加后缀或前缀。 ✓ DO 要使用数字来表示已有 API 的新版本——如果已有 API 的名字是唯一有意义的名字（也就是说，它是一个工业标准），不适宜添加后缀（或改名）。 // old API [Obsolete(\"This type is obsolete. Please use the new version of the same class X509Certificate2.\")] class X509Certificate { ... } // new API class X509Certificate2 { ... } X DO NOT 不要在标识符使用“Ex”（或类似的）后缀来区分相同 API 的不同版本。 // old API [Obsolete(\"This type is obsolete. ...\")] public class Car { ... } // new API public class CarEx { ... } // the wrong way public class CarNew { ... } // the wrong way public class Car2 { ... } // the wrong way public class Automobile { ... } // the wrong way 1.3 程序集和 DLL 的命名 程序集是一个部署单元，同时还代表托管代码程序的身份。虽然程序集可以分布在同一个或多个文件中，但一般来说一个程序集仅与一个 DLL 相对应。 要记住，名字空间与 DLL 和程序集是不同的概念。名字空间对开发人员来说是一组逻辑实体，而 DLL 和程序集则是在打包和部署时的一个单元。 DLL 可以因产品的组织以及其他原因而包含多个名字空间。由于名字空间的组织方式与 DLL 不同，因此应该单独设计。例如，如果决定把 DLL 命名为 MyCompany.MyTechnology，这并意味着 DLL 必须包含名为 MyCompany.MyTechnology 的名字空间。 ✓ DO 要为程序集和 DLL 选择提示性的名字，比如 System.Data，这样很容易就知道它的大致功能。程序集和 DLL 的名字不一定要和名字空间相对应，但在给程序集命名时遵循名字空间的名字也是合情合理的。 ✓ CONSIDER 考虑按照下面的模式给 DLL 命名： ..[.]dll 1.4 名字空间的命名 与其他的命名规范一样，为名字空间命名的目标是清晰，这样对使用的程序员来说，他们就能够立刻知道一个名字空间中大概有些什么。下面的模板给出了名字空间的一般规则： .(Product>|)[.][.] 下面是一些例子： System.Collections; System.Collections.Generic; System.Linq; System.Text; System.Text.RegularExpressions; System.Threading; System.Threading.Tasks; MyCompany.MyProduct; MyCompany.MyProduct.MyComponent; ✓ DO 要用公司名称作为名字空间的前缀，这样就可以避免与另一家公司使用相同的名字。 ✓ DO 要用稳定的、与版本无关的产品名称作为名字空间的第二层。 X DO NOT 不要根据公司的组织架构来决定名字空间的层次结构，因为公司内部组织的名字一般来说不会持续太长的时间。 ✓ DO 要使用 PascalCasing 大小写风格，并用点号来分隔名字空间中的各部分。如果商标使用了非传统的大小写风格，那么即使该风格与常规的大小写风格相背，也应该遵循商标的大小写风格。 ✓ CONSIDER 考虑在适当的时候在名字空间中使用复数形式。 例如，要使用 System.Collections，而不要用 System.Collection。但是，商标名称和首字母缩写词除外。例如，要用 System.IO, 而不要用 System.IOs。 X DO NOT 不要用相同的名字来命名名称空间与位于该名字空间中的类型。 例如，不要先将名字空间命名为 Debug，然后又在名字空间中提供一个名为 Debug 的类。许多编译器都要求用户在使用这样的类型时要加上完整的限定符。 名字空间和类型名的冲突 名字空间用来把类型组织成一个逻辑、易于浏览的层次结构。对解决在导入多个名字空间是可能引起的类型名的二义性，它们同样是不可或缺的。但即便如此，对那些通常会在一起使用的不同名字空间来说，仍不应该以此为借口在类型之间引入二义性。在常见的场景中，开发人员应该不需要给类型名加上限定符。 X DO NOT 不要引入太一般的类型名，比如 Element、Node、Log 以及 Message。 这样的名字很可能会在常见的场景中引起类型名的冲突。应该给这些一般化的类型名加上修饰语（FormElement、XmlNode、EventLog、SoapMessage）。 1.5 类、结构和接口的命名 ✓ DO 要用名词或者名词词组来给类型命名，在少数情况下也可以用形容词来给类型命名。在命名时要使用 PascalCasing 大小写风格。 X DO NOT 不要给类名加前缀（例如 “C”）。唯一的前缀是用于接口的 I（如 ICollection）。 ✓ CONSIDER 考虑让派生类的名字以基类的名字结尾。 这样可读性会非常好，而且请清晰地解释它们之间的关系。 例子有：ArgumentOutOfRangeException, 它是一种 Exception；SerializableAttribute ，它是一种 Attribute。但是，在运用这一条时，很重要的一点是要做出合理的判断；例如，即使 Button 类的名字没有出现 Control 字样，它仍然是一种 Control 实体。下面是一些正确的命名的例子： public class FileStream : Stream { ... } public class Button : Control { ... } ✓ DO 要让接口的名字以字母 I 开头，这样可以显示出该类型是一个接口。 例如，IComponent （描述性名称）、ICustomAttributeProvider （名词短语）以及 `IPersistable （形容词）都是恰当的接口名字。 ✓ DO 要确保一对类/接口的名字只相差一个 I 前缀，如果该类是该接口的标准实现。例如： public interface IComponent { ... } public class Component { ... } 1.5.1 泛型类型参数的命名 ✓ DO 要用描述性的名字来命名泛型类型参数——除非一个字母就足够了，而且描述性的名字并不能添加什么价值。 public interface ISerssionChannel { ... } public delegate TOutput Converter(TInput from); public class List { ... } ✓ CONSIDER 考虑用 T 来命名参数类型——如果类型只有一个类型参数，而且类型参数只有一个字母。 public int ICompare { ... } public delegate bool Predicate(T item); public struct Nullable where T : struct { ... } ✓ DO 要给描述性的类型参数加上 T 前缀。 public interface ISessionChannel whre TSession : ISession { TSession Session { get; } } ✓ CONSIDER 考虑在类型参数名中显示出施加于该类型参数上的限制。 例如，可以把一个被限制为ISession的类型参数命名为TSession。 1.5.2 常用类型的命名 如果要从 .NET 框架所包含的类型派生新类型，或者要实现 .NET 框架中的类型，那么遵循本节中的规范是非常重要的。 System.Attribute ✓ DO 要给自定义的标记（attribute） 类添加 Attribute 后缀 System.Delegate ✓ DO 要给用于事件处理的委托添加 EventHandler 后缀 ✓ DO 要给用于事件处理之外的那些委托添加 Callback 后缀 X DO NOT 不要给委托添加 Delegate 后缀 System.EventArgs ✓ DO 要添加 EventArgs 后缀 System.Enum X DO NOT 不要派生自该类：要用编程语言提供的关键字来代替。例如在 C# 中，要用 enum 关键字 X DO NOT 不要添加 Enum 或 Flag 后缀 System.Exception ✓ DO 要添加 Exception 后缀 System.Collections.IDictionary 和 System.Collections.Generic.IDictionary ✓ DO 要添加 Dictionary 后缀。 System.Collections.IEnumerable、System.Collections.ICollection、System.Collections.IList、System.Collections.Generic.IEnumerable、System.Collections.Generic.ICollection 和 System.Collections.Generic.IList ✓ DO 要添加 Collection 后缀 System.IO.Stream ✓ DO 要添加 Stream 后缀 System.Security.CodeAccessPermission 和 System.Security.IPermision ✓ DO 要添加 Permission 后缀 1.5.3 枚举类型的命名 ✓ DO 要遵循标准的 PascalCasing 大小写的命名规则 ✓ DO 要用单数名词来命名枚举类型，除非他表示的是位域（bit field）。 public enum ConsoleColor { Black, Blue, Cyan, ... } ✓ DO 要用复数名词来命名表示位域的枚举类型，这样的枚举类型也称为标记枚举（flag enum）。 [Flags] public enum ConsoleModifiers { Alt, Control, Shift } X DO NOT 不要给枚举类型的名字添加 Enum 后缀。 // bad naming public enum ColorEnum { ... } X DO NOT 不要给枚举类型的名字添加 Flag 或 Flags 后缀。 // Bad naming [Flags] public enum ColorFlags { ... } X DO NOT 不要给枚举类型值的名字添加前缀（例如，给 ADO 枚举类型添加“ad”前缀，给 rich text 枚举类型添加 “rtf”前缀）。 public enum ImageMode { ImageModeBitmap = 0, // Image prefix is not necessary ImageModeGrayScale = 1, ... } 下面的命名会更好： public enum ImageMode { Bitmap = 0, GrayScale = 1, ... } 1.6 类成员的命名 1.6.1 方法的命名 ✓ DO 要用动词或动词词组来命名方法。 public class String { public int CompareTo(...); public string[] Split(...); public string Trim(...); } ✓ DO 要使用 Async 作为异步方法的后缀。 public Task GetAsync(...) { ... } 1.6.2 属性（Property）的命名 ✓ DO 要用名词、名词词组或形容词来命名属性。 public class String { public int Length { get; } } X DO NOT 不要让属性看起来与 \"Get\" 方法的名字相似，如下面的例子所示。 public string TextWriter { get { ... } set { ... } } public string GetTextWriter(int value) { ... } ✓ DO 要用肯定的短语 (CanSeek 而不是 CantSeek）来命名布尔属性。如果有帮助，还可以有选择的给布尔属性添加“Is”、“Can”或“Has”等前缀。 例如，CanRead 要比 Readable 更容易理解，但 Created 却比 IsCreated 的可读性更好。前缀通常是多余的，也没有必要，尤其是在有 Intellisense 的代码编辑器中。输入 MyObject.Enalbed = 与输入 MyObject.IsEanbled =一样清楚，两种情况下 Intellisense 都会提示你选择 true 或 false，但后缀更为冗长一些。 if (collections.Contains(item)) // better if (collections.IsContains(item)) // bad if (stream.CanSeek) // better if (stream.IsSeekable) // bad ✓ CONSIDER 考虑用属性的类型名来命名属性。 public enum Color { ... } public class Control { public Color Color { get { ... } set { ... } } } 1.6.3 事件的命名 ✓ DO 要用动词或动词词组短语来命名事件。 这样的例子包括 Clicked、Painting、DroppedDown 等等。 ✓ DO 要用现在时和过去时来赋予事件名以之前和之后的概念。 X DO NOT 不要用“Before”或“After”前缀或后缀来区分前缀事件或后置事件。 ✓ DO 要在命名事件函数（用作事件类型的委托）时加上“EventHandler”后缀，如下面的例子所示： public delegate void ClickedEventHandler(object sender, ClickedEventArgs e); ✓ DO 要在事件函数中用 sender 和 e 作为两个参数的名字。 public delegate void EventHandler(object sender, EventArgs e); ✓ DO 要在命名事件的参数类是加上“EventArgs”后缀。 public class ClickedEventArgs: EventArgs { private readonly int _x; private readonly int _y; public ClickedEventArgs(int x, int y) { this._x = x; this._y = y; } public int X { get { return _x; } } public int Y { get { return _y; } } } 1.6.4 字段的命名 ✓ DO 要用名词或名词短语来命名字段。 ✓ DO 要在命名常量字段、静态公有字段和静态受保护字段时使用 PascalCasing 大小写风格。 public class String { public static readonly string Empty; } ✓ DO 要在命名私有字段时使用 _camelCasing 大小写风格。 public Coder { private int _age; public int Age { get { return _age; } } } X DO NOT 不要给字段添加前缀。 例如，不要用“g”或 “s”来区分静态或非静态字段。 1.7 参数的命名 ✓ DO 要在命名参数时使用 camelCasing 大小写风格。 public class String { public bool Contains(string value); public string Remove(int startIndex, int count); } ✓ DO 要使用具有描述性的参数名。 参数名应该具备足够的描述性，使得在大多数情况下，用户根据参数的名字和类型就能够确定他的意思。 ✓ CONSIDER 考虑根据参数的意思而不是参数的类型命名参数。 1.8 JSON 的命名 ✓ DO 要在命名 JSON 的属性名时使用 camelCasing 大小写风格。 public class Coder { public int Age { get; set; } public string FirstName { get; set; } public string LastName { get; set; } ... } { \"age\": 18, \"firstName\": \"ROY\", \"lastName\": \"XU\", ... } 1.9 版本号的命名 ✓ DO 要按照下面的语义化版本的格式命名程序集、DLL、NuGet 以及软件的发行版本号等等。 MAJOR.MINOR.PATCH MAJOR version 非兼容性修改 when you make incompatible API changes, MINOR version 兼容性修改 when you add functionality in a backwards-compatible, and PATH version 兼容性的缺陷修复 when you make backwards-compatible bug fixes. 其他可选的标签用于对 MAJOR.MINOR.PATCH 格式的一些信息补充，比如 aplha, beta, preview 等等 Additional lablels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format. For more information, see https://semver.org/. "},"naming-guidelines/":{"url":"naming-guidelines/","title":"1.1 大小写约定","keywords":"","body":"本章描述了一般的命名规范，包括如何使用大小写，如何为标识符选择恰当的名字，以及如何使用某些特定的术语。本章还为名字空间、类型、成员、参数、程序集、版本号以及 JSON 的命名提供了具体的规范。 1.1 大小写规范 1.1.1 标志符的大小写规则 为了区分一个标识符的多个单词，把标识符中的每个单词的首字母大写。不要用下划线来区分单词，或者在标识符中的任何地方使用下划线（私有字段采用 _camelCasing 风格）。有两种合适的方法来大写标志符中的字母： PascalCasing camelCasing PascalCasing 约定被用于除了参数名之外的所有标识符，它把标识符中每个单词的首字母（包括长度为两个字符以上的首字母缩写词）大写，如下面的例子所示： PropertyDescriptor HtmlTag 两个字母长的首字母缩写词是一个特例，在这种情况下两个字母都要大写，如下面的标识符所示： IOStream cameCasing 约定仅用于参数的名字，它把标识符中除了第一个单词之外的所有单词的首字母大写，如下面的例子所示。在例子中，如果 camelCasing 风格的标识符以两个字母长的首字母缩写词开始，那么这个缩写词都要小写。 propertyDescriptor ioStream htmlTag 下面是一些用于标识符的基本大小写规范。 ✓ DO 要把 PascalCasing 用于由多个单词构成的名字空间、类型以及成员的名字。 ✓ DO 要把 camelCasing 用于参数的名字。 表 1-1 不同类型的标识符的大小写规则 标识符 大小写 样例 名字空间 Pascal namespace System.Security { ... } 类型 Pascal public class StreamReader { ... } 接口 Pascal public interface IEnumerable { ... } 方法 Pascal public virtual string ToString(); 属性 Pascal public int Length { get; } 事件 Pascal public event EventHandler Exited; 字段（静态） Pascal puglic static readonly TimeSpan InfiniteTimeout; 枚举值 Pascal File Mode { Append, ...} 参数 Camel public static int ToInt32(string value); 1.1.2 首字母缩写词的大小写 一般来说，避免在标识符的名字中使用首字母缩写词是很重要的，除非他们是普遍使用的，能够立刻被使用的人所理解。例如，HTML、XML 和 IO 很容易理解，但不怎么常用的首字母缩写词绝对应该避免。 注：首字母缩写词（acronyms）与单词缩写（abbreviations）是有区别的，绝对不应该在标识符中使用单词缩写。首字母缩写词是由一个短语的首字母组成的，而单词缩写则仅仅把一个单词的长度变短。 从定义上讲，首字母缩写词必须至少有两个字母。由三个或以上的字母组成的首字母缩写词遵循与任何其他单词一样的规范，只有第一个字母大写，除非是 camelCasing 风格的参数名称中的第一个单词，在这种情况下第一个单词全部小写。例如： public void StartIO(Stream ioStream, bool closeIOStream); public void ProcessHtmlTag(string htmlTag); ✓ DO 要把两个字母的首字母缩写词全部大写，除非它是 camelCasing 风格的参数的第一个单词。 System.IO public void StartIO(Stream ioStream); ✓ DO 要把由三个或者三个以上字母组成的首字母缩写词的第一个字母大写。只有第一个字母大写，除非首字母缩写词是 camelCasing 风格的标识符的第一个单词。 System.Xml public void ProcessHtmlTag(string htmlTag) X DO NOT 不要把 camelCasing 风格的标识符头部的任何首字母缩写词的任何字母大写，无论首字母缩写词的长度是多少。 1.1.3 复合词和常用术语的大小写 在涉及大小写时，大多数复合词术语要作为单个单词处理。 X DO NOT 不要把所谓闭合形式的复合词中的每个单词的首字母大写。 这些复合词要写成一个单词，比如 endpoint。为了统一大小写规范，我们把闭合形式的复合词作为一个单词处理。 表 1-2 常用的复合词和常用术语的大小写及拼写 Pascal Camel Not BitFlag bitFlag Bitflag Callback callback CallBack Canceled canceled Cancelled DoNot doNot Dont Email email EMail Endpoint endpoint EndPoint FileName fileName Filename Gridline gridline GridLine Hashtable hashtable HashTable Id id ID Indexes indexes Indices LogOff logOff LogOut LogOn logOn LogIn Metadata metadata MetaData, metaData Multipanel multiplanel MultiPanel Multiview multiview MultiView Namespace namespace NameSpace Ok ok OK Pi pi PI SignIn signIn SignOn SignOut signOut signOff UserName userName Username WhiteSpace whiteSpace WhiteSpace Writable writable Writeable 有两个常用的其他术语，它们本身属于另一个类别，因为它们是俚语性质的常用缩写。这两个单词是 Ok 和 Id (它们的大小写应该如显示的那样），虽然前面的规范说过名字不应该使用缩写，但它们是例外。 1.2 通用命名规范 本节描述了一些通用的命名约束，它们涉及到单词的选择、单词缩写和首字母缩写词的使用规范以及如何避免使用编程语言特有的名字。 1.2.1 单词的选择 标识符的名字要一目了然，应该清楚地说明每个成员做什么，以及每个类型和参数表示什么。为此，名字的意思清楚要比长度短更重要。 ✓ DO 要为标识符选择易于阅读的名字。 例如，一个名为 HorizontalAlignment 的属性就比 AlignmentHorizontal 更容易阅读。 ✓ DO 要更看重可读性，而不是更看重简短性。属性名 CanScrollHorizontally 要胜过 ScrollableX （不太明显地引用到了 X 坐标轴）。 X DO NOT 不要使用下划线、连字符以及其他任何既非字母也非数字的字符。 X DO NOT 不要使用匈牙利命名法。 X AVOID 避免使用与广泛使用的编程语言的关键字有冲突的标识符。如 C# 中的 @ 符号等。 1.2.2 使用单词缩写和首字母缩写 X DO NOT 不要使用缩写词和缩约词（如 won't 是 will not 的缩约词）作为标识符的一部分。例如，要用 GetWindow，而不要用 GetWin。 X DO NOT 不要使用未被广泛接受的首字母缩写词，即使是被广泛接受的首字母缩写词，也只应该在必须的时候才使用。 1.2.3 避免使用语言特有的名字 对那些所谓的基本类型，CLR 平台上的编程语言通常都有自己的名称（别名）来称呼它们。例如 int 是 C# 中 System.Int32 的别名。 ✓ DO 要给类型名使用语义上有意义的名字，而不要使用语言特有的关键字。 例如，GetLength 这个名字比 GetInt 要好。 ✓ DO 要使用 CLR 的通用类型名，而不要使用语言特有的别名——如果除了类型之外，标识符没有其他的语义。 例如，一个把类型转换为 System.Int64 的方法应该被命名为 ToInt64，而不是 ToLong。 表 1-3 语言特有的类型名及对应的 CLR 类型名 C# Visual Basic C++ CLR sbyte SByte char SByte byte Byte unsigned char Byte short Short short Int16 ushort UInt16 unsigned short UInt16 int Integer int Int32 uint UInt32 unsigned int UInt32 long Long __int64 Int64 ulong UInt64 unsigned __int64 UInt64 float Single float Single double Double double Double bool Boolean bool Boolean char Char wchar_t Char string String String String object Object Object Object ✓ DO 要使用常见的名字，比如 value 或 item，而不要重复类型的名字——如果除了类型之外，标识符没有其他的语义，而且参数的类型不重要。 下面是一个很好的例子，类提供的这些方法可以把各种不同的数据类型写入流中： void Write(double value); void Write(float value); void Write(short value); 1.2.4 为已有 API 的新版本命名 ✓ DO 要在创建已有 API 的新版本时使用与旧 API 相似的名字。 这有助于突出 API 之间的关系。 class AppDomain { [Obsolete(\"AppDomain.SetCachePath has been deprecated. Please use AppDomainSetup.CachePath instead.\")] public void SetCachePath(string path) { ... } } class AppDomainSetup { public string CachePath { get { ... } set { ... } } } ✓ DO 要优先使用后缀而不是前缀来表示已有 API 的新版本。 这有助于在浏览文档或使用 Intellisense 时发现新版本。由于大多数浏览器和 Intellisense 按字母的顺序显示标识符，因此旧 API 与新 API 在位置上会非常接近。 ✓ CONSIDER 考虑使用全新但有意义的标识符，而不是简单地给已有标识符添加后缀或前缀。 ✓ DO 要使用数字来表示已有 API 的新版本——如果已有 API 的名字是唯一有意义的名字（也就是说，它是一个工业标准），不适宜添加后缀（或改名）。 // old API [Obsolete(\"This type is obsolete. Please use the new version of the same class X509Certificate2.\")] class X509Certificate { ... } // new API class X509Certificate2 { ... } X DO NOT 不要在标识符使用“Ex”（或类似的）后缀来区分相同 API 的不同版本。 // old API [Obsolete(\"This type is obsolete. ...\")] public class Car { ... } // new API public class CarEx { ... } // the wrong way public class CarNew { ... } // the wrong way public class Car2 { ... } // the wrong way public class Automobile { ... } // the wrong way 1.3 程序集和 DLL 的命名 程序集是一个部署单元，同时还代表托管代码程序的身份。虽然程序集可以分布在同一个或多个文件中，但一般来说一个程序集仅与一个 DLL 相对应。 要记住，名字空间与 DLL 和程序集是不同的概念。名字空间对开发人员来说是一组逻辑实体，而 DLL 和程序集则是在打包和部署时的一个单元。 DLL 可以因产品的组织以及其他原因而包含多个名字空间。由于名字空间的组织方式与 DLL 不同，因此应该单独设计。例如，如果决定把 DLL 命名为 MyCompany.MyTechnology，这并意味着 DLL 必须包含名为 MyCompany.MyTechnology 的名字空间。 ✓ DO 要为程序集和 DLL 选择提示性的名字，比如 System.Data，这样很容易就知道它的大致功能。程序集和 DLL 的名字不一定要和名字空间相对应，但在给程序集命名时遵循名字空间的名字也是合情合理的。 ✓ CONSIDER 考虑按照下面的模式给 DLL 命名： ..[.]dll 1.4 名字空间的命名 与其他的命名规范一样，为名字空间命名的目标是清晰，这样对使用的程序员来说，他们就能够立刻知道一个名字空间中大概有些什么。下面的模板给出了名字空间的一般规则： .(Product>|)[.][.] 下面是一些例子： System.Collections; System.Collections.Generic; System.Linq; System.Text; System.Text.RegularExpressions; System.Threading; System.Threading.Tasks; MyCompany.MyProduct; MyCompany.MyProduct.MyComponent; ✓ DO 要用公司名称作为名字空间的前缀，这样就可以避免与另一家公司使用相同的名字。 ✓ DO 要用稳定的、与版本无关的产品名称作为名字空间的第二层。 X DO NOT 不要根据公司的组织架构来决定名字空间的层次结构，因为公司内部组织的名字一般来说不会持续太长的时间。 ✓ DO 要使用 PascalCasing 大小写风格，并用点号来分隔名字空间中的各部分。如果商标使用了非传统的大小写风格，那么即使该风格与常规的大小写风格相背，也应该遵循商标的大小写风格。 ✓ CONSIDER 考虑在适当的时候在名字空间中使用复数形式。 例如，要使用 System.Collections，而不要用 System.Collection。但是，商标名称和首字母缩写词除外。例如，要用 System.IO, 而不要用 System.IOs。 X DO NOT 不要用相同的名字来命名名称空间与位于该名字空间中的类型。 例如，不要先将名字空间命名为 Debug，然后又在名字空间中提供一个名为 Debug 的类。许多编译器都要求用户在使用这样的类型时要加上完整的限定符。 名字空间和类型名的冲突 名字空间用来把类型组织成一个逻辑、易于浏览的层次结构。对解决在导入多个名字空间是可能引起的类型名的二义性，它们同样是不可或缺的。但即便如此，对那些通常会在一起使用的不同名字空间来说，仍不应该以此为借口在类型之间引入二义性。在常见的场景中，开发人员应该不需要给类型名加上限定符。 X DO NOT 不要引入太一般的类型名，比如 Element、Node、Log 以及 Message。 这样的名字很可能会在常见的场景中引起类型名的冲突。应该给这些一般化的类型名加上修饰语（FormElement、XmlNode、EventLog、SoapMessage）。 1.5 类、结构和接口的命名 ✓ DO 要用名词或者名词词组来给类型命名，在少数情况下也可以用形容词来给类型命名。在命名时要使用 PascalCasing 大小写风格。 X DO NOT 不要给类名加前缀（例如 “C”）。唯一的前缀是用于接口的 I（如 ICollection）。 ✓ CONSIDER 考虑让派生类的名字以基类的名字结尾。 这样可读性会非常好，而且请清晰地解释它们之间的关系。 例子有：ArgumentOutOfRangeException, 它是一种 Exception；SerializableAttribute ，它是一种 Attribute。但是，在运用这一条时，很重要的一点是要做出合理的判断；例如，即使 Button 类的名字没有出现 Control 字样，它仍然是一种 Control 实体。下面是一些正确的命名的例子： public class FileStream : Stream { ... } public class Button : Control { ... } ✓ DO 要让接口的名字以字母 I 开头，这样可以显示出该类型是一个接口。 例如，IComponent （描述性名称）、ICustomAttributeProvider （名词短语）以及 `IPersistable （形容词）都是恰当的接口名字。 ✓ DO 要确保一对类/接口的名字只相差一个 I 前缀，如果该类是该接口的标准实现。例如： public interface IComponent { ... } public class Component { ... } 1.5.1 泛型类型参数的命名 ✓ DO 要用描述性的名字来命名泛型类型参数——除非一个字母就足够了，而且描述性的名字并不能添加什么价值。 public interface ISerssionChannel { ... } public delegate TOutput Converter(TInput from); public class List { ... } ✓ CONSIDER 考虑用 T 来命名参数类型——如果类型只有一个类型参数，而且类型参数只有一个字母。 public int ICompare { ... } public delegate bool Predicate(T item); public struct Nullable where T : struct { ... } ✓ DO 要给描述性的类型参数加上 T 前缀。 public interface ISessionChannel whre TSession : ISession { TSession Session { get; } } ✓ CONSIDER 考虑在类型参数名中显示出施加于该类型参数上的限制。 例如，可以把一个被限制为ISession的类型参数命名为TSession。 1.5.2 常用类型的命名 如果要从 .NET 框架所包含的类型派生新类型，或者要实现 .NET 框架中的类型，那么遵循本节中的规范是非常重要的。 System.Attribute ✓ DO 要给自定义的标记（attribute） 类添加 Attribute 后缀 System.Delegate ✓ DO 要给用于事件处理的委托添加 EventHandler 后缀 ✓ DO 要给用于事件处理之外的那些委托添加 Callback 后缀 X DO NOT 不要给委托添加 Delegate 后缀 System.EventArgs ✓ DO 要添加 EventArgs 后缀 System.Enum X DO NOT 不要派生自该类：要用编程语言提供的关键字来代替。例如在 C# 中，要用 enum 关键字 X DO NOT 不要添加 Enum 或 Flag 后缀 System.Exception ✓ DO 要添加 Exception 后缀 System.Collections.IDictionary 和 System.Collections.Generic.IDictionary ✓ DO 要添加 Dictionary 后缀。 System.Collections.IEnumerable、System.Collections.ICollection、System.Collections.IList、System.Collections.Generic.IEnumerable、System.Collections.Generic.ICollection 和 System.Collections.Generic.IList ✓ DO 要添加 Collection 后缀 System.IO.Stream ✓ DO 要添加 Stream 后缀 System.Security.CodeAccessPermission 和 System.Security.IPermision ✓ DO 要添加 Permission 后缀 1.5.3 枚举类型的命名 ✓ DO 要遵循标准的 PascalCasing 大小写的命名规则 ✓ DO 要用单数名词来命名枚举类型，除非他表示的是位域（bit field）。 public enum ConsoleColor { Black, Blue, Cyan, ... } ✓ DO 要用复数名词来命名表示位域的枚举类型，这样的枚举类型也称为标记枚举（flag enum）。 [Flags] public enum ConsoleModifiers { Alt, Control, Shift } X DO NOT 不要给枚举类型的名字添加 Enum 后缀。 // bad naming public enum ColorEnum { ... } X DO NOT 不要给枚举类型的名字添加 Flag 或 Flags 后缀。 // Bad naming [Flags] public enum ColorFlags { ... } X DO NOT 不要给枚举类型值的名字添加前缀（例如，给 ADO 枚举类型添加“ad”前缀，给 rich text 枚举类型添加 “rtf”前缀）。 public enum ImageMode { ImageModeBitmap = 0, // Image prefix is not necessary ImageModeGrayScale = 1, ... } 下面的命名会更好： public enum ImageMode { Bitmap = 0, GrayScale = 1, ... } 1.6 类成员的命名 1.6.1 方法的命名 ✓ DO 要用动词或动词词组来命名方法。 public class String { public int CompareTo(...); public string[] Split(...); public string Trim(...); } ✓ DO 要使用 Async 作为异步方法的后缀。 public Task GetAsync(...) { ... } 1.6.2 属性（Property）的命名 ✓ DO 要用名词、名词词组或形容词来命名属性。 public class String { public int Length { get; } } X DO NOT 不要让属性看起来与 \"Get\" 方法的名字相似，如下面的例子所示。 public string TextWriter { get { ... } set { ... } } public string GetTextWriter(int value) { ... } ✓ DO 要用肯定的短语 (CanSeek 而不是 CantSeek）来命名布尔属性。如果有帮助，还可以有选择的给布尔属性添加“Is”、“Can”或“Has”等前缀。 例如，CanRead 要比 Readable 更容易理解，但 Created 却比 IsCreated 的可读性更好。前缀通常是多余的，也没有必要，尤其是在有 Intellisense 的代码编辑器中。输入 MyObject.Enalbed = 与输入 MyObject.IsEanbled =一样清楚，两种情况下 Intellisense 都会提示你选择 true 或 false，但后缀更为冗长一些。 if (collections.Contains(item)) // better if (collections.IsContains(item)) // bad if (stream.CanSeek) // better if (stream.IsSeekable) // bad ✓ CONSIDER 考虑用属性的类型名来命名属性。 public enum Color { ... } public class Control { public Color Color { get { ... } set { ... } } } 1.6.3 事件的命名 ✓ DO 要用动词或动词词组短语来命名事件。 这样的例子包括 Clicked、Painting、DroppedDown 等等。 ✓ DO 要用现在时和过去时来赋予事件名以之前和之后的概念。 X DO NOT 不要用“Before”或“After”前缀或后缀来区分前缀事件或后置事件。 ✓ DO 要在命名事件函数（用作事件类型的委托）时加上“EventHandler”后缀，如下面的例子所示： public delegate void ClickedEventHandler(object sender, ClickedEventArgs e); ✓ DO 要在事件函数中用 sender 和 e 作为两个参数的名字。 public delegate void EventHandler(object sender, EventArgs e); ✓ DO 要在命名事件的参数类是加上“EventArgs”后缀。 public class ClickedEventArgs: EventArgs { private readonly int _x; private readonly int _y; public ClickedEventArgs(int x, int y) { this._x = x; this._y = y; } public int X { get { return _x; } } public int Y { get { return _y; } } } 1.6.4 字段的命名 ✓ DO 要用名词或名词短语来命名字段。 ✓ DO 要在命名常量字段、静态公有字段和静态受保护字段时使用 PascalCasing 大小写风格。 public class String { public static readonly string Empty; } ✓ DO 要在命名私有字段时使用 _camelCasing 大小写风格。 public Coder { private int _age; public int Age { get { return _age; } } } X DO NOT 不要给字段添加前缀。 例如，不要用“g”或 “s”来区分静态或非静态字段。 1.7 参数的命名 ✓ DO 要在命名参数时使用 camelCasing 大小写风格。 public class String { public bool Contains(string value); public string Remove(int startIndex, int count); } ✓ DO 要使用具有描述性的参数名。 参数名应该具备足够的描述性，使得在大多数情况下，用户根据参数的名字和类型就能够确定他的意思。 ✓ CONSIDER 考虑根据参数的意思而不是参数的类型命名参数。 1.8 JSON 的命名 ✓ DO 要在命名 JSON 的属性名时使用 camelCasing 大小写风格。 public class Coder { public int Age { get; set; } public string FirstName { get; set; } public string LastName { get; set; } ... } { \"age\": 18, \"firstName\": \"ROY\", \"lastName\": \"XU\", ... } 1.9 版本号的命名 ✓ DO 要按照下面的语义化版本的格式命名程序集、DLL、NuGet 以及软件的发行版本号等等。 MAJOR.MINOR.PATCH MAJOR version 非兼容性修改 when you make incompatible API changes, MINOR version 兼容性修改 when you add functionality in a backwards-compatible, and PATH version 兼容性的缺陷修复 when you make backwards-compatible bug fixes. 其他可选的标签用于对 MAJOR.MINOR.PATCH 格式的一些信息补充，比如 aplha, beta, preview 等等 Additional lablels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format. For more information, see https://semver.org/. "},"design-guidelines-for-exceptions/":{"url":"design-guidelines-for-exceptions/","title":"2 异常使用规范","keywords":"","body":"2.1 抛出异常 X DO NOT 不要返回错误码。 ✓ DO 要通过抛出异常的方式来报告操作失败。 操作失败就是成员不能完成应该完成的任务（成员的名字所暗示的任务）。例如，如果OpenFile方法无法打开文件并将文件句柄返回给调用方，那么这就可以称为操作失败。 X DO NOT 不要在正常的控制流中使用异常，如果能够避免的话。 // Tester-Doer 模式 ICollection collection = ...; if (!collection.IsReadOnly) // tester { collection.Add(additionalNumber); // doer } if (int.TryParse(..., out var number)) { ... } // Try-Parse 模式 ✓ CONSIDER 考虑抛出异常可能会对性能造成的影响。 ✓ DO 要为所有的异常撰写文档，并把它们作为协定的一部分，前提是这些异常是由于违反公用（public）成员的协定而抛出的。 异常是协定的一部分，不应该随版本而变化（也就是说，既不应该改变异常的类型，也不应该增加新的异常）。 X DO NOT 不要让公有成员根据某个选项决定是否抛出异常。 // bad design public Type GetType(string name, bool throwOnError) X DO NOT 不要把异常用作公有成员的返回值或输出参数。 // bad desgin public Exception DoSomething() { ... } ✓ CONSIDER 考虑使用辅助方法来创建异常。 从不同的地方抛出一个异常是很常见的，为了避免代码重复，可以使用辅助函数来创建异常并对其属性进行初始化。 另外，抛出异常的成员无法被内联（inlining），如果把抛出异常的语句移到辅助函数中，那么成员就有可能被内联。例如： class File { public byte[] Read(int bytes) { if (!ReadFile(handle, bytes)) { ThrowNewFileIOException(...); } } void ThrowNewFileIOException(...) { string description = ... ;// build localized string throw new FileIOException(description); } } X DO NOT 不要在异常筛选器（exception filter）中抛出异常。 如果在异常筛选器中触发异常，那么 CLR 会捕获异常，筛选器会返回 false。由于同实际运行筛选器并显示地返回 false 相比，这两种情况很难区分，因此调试起来会非常困难。 // This is bad desgin. The exception filter (when clause) // may throw an exception when the InnerException property // returns null. try { // ... } catch (Exception e) when (e.InnerException.Message.StartsWith(\"File\")) { // ... } X AVOID 避免显示地从 finally 代码块中抛出异常。隐式地抛出异常，即在调用其他方法时由其他方法抛出异常，是可以接受的。 2.2 为抛出的异常选择合适的类型 ✓ CONSIDER 考虑优先使用 System 名字空间中已有的异常，而不是自己创建新的异常。 ✓ DO 要使用自定义的异常类型，如果对错误的处理方式与其他已有的异常有所不同。否则的话，应该使用已有的异常。 X DO NOT 不要仅仅为了拥有自己的异常而创建并使用新的异常。 ✓ DO 要使用最合理、最具针对性的异常。 例如，如果传入的参数是 null，那么应该抛出 ArgumentNullException，而不是其基类 ArgumentException。 X AVOID 避免抛出 System.Exception 异常。 2.2.1 错误消息的设计 ✓ DO 要在抛出异常时为开发人员提供丰富而有意义的错误消息。 X AVOID 避免在异常消息中使用问号和惊叹号。 X DO NOT 不要在没有得到许可的情况下在异常消息中泄漏安全信息。 ✓ CONSIDER 考虑把抛出的异常消息本地化，如果希望组件为说不同语言的开发人员所使用。 2.2.2 异常处理 如果用 catch 代码块来捕获某个特定类型的异常，并完全理解在 catch 代码块之后继续执行对应用程序来说意味着什么，那么我们说这种情况是对异常进行了处理。举个例子，在试图打开一个配置文件时，如果文件不存在，那么可以捕获 FileNotFoundException，并在这种情况下使用默认的配置文件。 如果捕获的异常具体类型不确定（通常都是如此），并在不完全理解失败的原因或没有对失败做出反应的情况下让应用程序继续执行，那么我们说着种情况是把异常吞了。 X AVOID 避免在应用程序的代码中，在捕获具体类型不确定的异常（比如 System.Exception、System.SystemException 等等）时，把错误吞了。 try { File.Open(...); } catch (Exception e) { } // swallow 'all' exceptions - don't do this! ✓ CONSIDER 考虑捕获特定类型的异常，如果理解该异常在具体环境中产生的原因，并能对错误做出适当的反应。 X DO NOT 不要捕获不应该捕获的异常。通常应该允许异常沿着调用栈向上传递。 ✓ DO 要在清理工作时使用 try-finally, 避免使用 try-catch。 FileStream stream = null; try { stream = new FileStream(...); } finally { if (stream != null) { stream.Close(); } } // C# 提供了 using 语句，这样在清理那些实现了 IDisposable 接口的对象时，就 // 可以使用 using 语句而不必用 try-finally。 using (FileStream stream = new FileStream(...)) { // ... } ✓ DO 要在捕获并重新抛出异常时使用空的 throw 语句。这是保持调用栈的最好方法。 public void DoSomething(FileStream file) { long position = file.Position; try { ...; // do some reading with the file } catch { file.Position = position; // unwind on failure throw; // rethrow } } 当抛出新的异常时（与重新抛出原来的异常相比），所报告的错误不再是实际发生的错误，而这不利于应用程序的调试。因此，应该优先重新抛出原来的异常，而不要抛出新的异常。最好是完全避免捕获和（重新）抛出异常。 2.3 自定义异常的设计 X AVOID 避免太深层次的继承层次。 ✓ DO 要从 System.Exception 或其他常用的异常基类派生新的异常类。 ✓ DO 要在命名异常类时使用 \"Exception\" 后缀。 ✓ DO 要使异常可序列化。为了使异常能够在跨应用程序和跨远程边界时仍能正常工作，这样做是必须的。 ✓ DO 要为所有的异常（自少）提供下面这些常用的构造函数。 要确保参数的名字和类型与下面的例子完全一样。 public class SomeException : Exception { public SomeException() { } public SomeException(string message) : base(message) { } public SomeException(string message, Exception innerException) : base(message, innerException) { } // this constructor is needed for serialization protected SomeException(SerializationInfo info, StreamingContext context) : base(info, context) { } } ✓ DO 要通过 ToString 的重载方法来报告对安全敏感的信息，前提是必须先获得相应的许可。 ✓ CONSIDER 考虑为异常定义属性，这样就能够从程序中获得与异常相关的（除了消息字符串之外的）额外信息。 2.4 异常与性能 X DO NOT 不要因异常可能对性能造成的负面影响而使用错误码。 ✓ CONSIDER 考虑在方法中使用 Tester-Doer 模式来避免异常而引起的性能问题，如果该方法在普通的场景中都可能会抛出异常。 // Tester-Doer 模式 ICollection numbers = ... ... if (!numbers.IsReadOnly) // 用来对条件进行测试的成员称为 tester. { numbers.Add(1); // 用来执行实际的操作并可能会抛出异常的成员称为 doer. } 如果有多个线程同时访问一个对象，那么可能会出现问题。例如，一个线程可能运行 tester 方法并通过测试，但在 doer 方法运行时，另一个线程可能会改变对象的状态并导致 doer 的操作失败。虽然这个模式可能会提供性能，但是它也会引入竟态条件，因此在使用时必须极其小心。 ✓ CONSIDER 考虑在方法中使用 Try-Parse 模式来避免因异常而引起的性能问题，如果该方法在普通的场景中都可能会抛出异常。 public struct DateTime { public static DateTime Parse(string dateTime) { ... } public static bool TryParse(string dateTime, out DateTime result) { ... } } ✓ DO 要在实现 Try-Parse 模式时使用 “Try”前缀，并用布尔类型作为方法的返回类型。 ✓ DO 要为每个使用 Try-Parse 模式的方法提供一个会抛出异常的对应成员。 "},"usage-guidelines/":{"url":"usage-guidelines/","title":"3 常用类型使用规范","keywords":"","body":"3.1 数组（Arrays） ✓ DO 要在公用（public）API 中优先使用集合，而不是优先使用数组。 public class Order { public Collection Items { get { ... } } } X DO NOT 不要使用只读的数组字段。虽然字段本身是只读的，用户不能对其进行修改，但用户可以修改数组的元素。 public sealed class Path { public static readonly char[] InvalidPathChars = { '\\\"', '', '|' }; } 事实上用户可以修改数组中的值，就像下面这样： Path.InvalidPathChars[0] = 'A'; ✓ CONSIDER 考虑使用不规则数组（jagged array），不要使用多维数组。 // jagged array int[][] jaggedArray = { new int[] { 1, 2, 3, 4 }, new int[] { 5, 6, 7 }, new int[] { 8 }, new int[] { 9 }, }; // multidimensional arrays int[,] multiDimArray = { { 1, 2, 3, 4 }, { 5, 6, 7, 0 }, { 8, 0, 0, 0 }, { 9, 0, 0, 0 }, }; 3.2 标记（Attributes） 标记（attribute）是一种注解，可以用于各种编程元素，比如程序集、类型、成员、参数。它们存储在程序集的元数据中，在运行时可以通过反射 API 来访问。 ✓ DO 要在命名自定义 attribute 类时添加“Attribute”后缀。 ✓ DO 要在自定义的 attribute 时使用 AttributeUsageAttribute。 ✓ DO 要为可选参数（optional property, 或 optional argument）提供可设置的属性（Property）。 public class NameAttribute : Attribute { ... public int Age { get { ... } set { ... } } // optional argument } ✓ DO 要为必填参数（required property 或 required argument）提供只读属性。 public class NameAttribute : Attribute { public NameAttribute(string userName) { ... } // required argument public string UserName { get { ... } } ... } ✓ DO 要提供构造函数参数来对必填参数进行初始化。每个参数应该与相同的属性名相同（虽然大小写会不同）。 public class NameAttribute : Attribute { public NameAttribute(string userName) { ... } // required argument public string UserName { get { ... } } // required argument ... } X AVOID 避免提供构造函数参数来对与可选参数对应的属性进行初始化。 // bad design public class NameAttribute : Attribute { public NameAttribute(string userName) { ... } // required argument public string UserName { get { ... } set { ... } } // optional argument ... } X AVOID 避免对自定义 attribute 的构造函数进行重载（overload）。 // bad design public class NameAttribute : Attribute { public NameAttribute() { ... } public NameAttribute(...) { ... } ... } ✓ DO 要尽可能将自定义 attribute 类密封（sealed）起来。这样会使查找 attribute 更快。 public sealed class NameAttribute : Attribute { ... } 3.3 集合（Collections） X DO NOT 不要在公用 API 中使用弱类型集合。 如果返回值和参数表示一个集合元素，那么其类型应该与元素类型完全一致，而不应该是元素类型的任何基类（这只适合与集合的公用成员）例如，存储 Component 的集合不应该提供以 object 为参数的公用 Add 方法，或以 IComponent 为返回值的公用索引器。 // bad desgin public class ComponentDesigner { public IList Components { get { ... } } } // good desgin public class ComponentDesigner { public Collection Components { get { ... } } ... } X DO NOT 不要在公用 API 中使用 ArrayList 或 List。 // bad desgin public class Order { public List Items { get { ... } } ... } // good desgin public class Order { public Collection Items { get { ... } } ... } X DO NOT 不要在公用 API 中使用 HashTable 或者 Dictionary。 ✓ DO 要用最泛的类型（即继承层次中最靠近基类的类型）作为参数类型。大多数以集合为参数的成员都使用 IEnumerable 接口。 public void PrintNames(IEnumerable names) { foreach (var name in names) { Console.WriteLine(name); } } X AVOID 避免使用 ICollection 或 ICollection 来做参数，如果其目的仅仅是为了访问该接口的 Count 属性。 X DO NOT 不要提供可设置的集合属性。 // bad desgin public class Order { public Collection Items { get { ... } set { ... } } ... } // good desgin public class Order { public Collection Items { get { ... } } ... } ✓ DO 要用 Collection或其子类作为属性或返回值来表示可读写的集合。 public Collection Sessions { get; } ✓ DO 要用 ReadOnlyCollection 或其子类作为属性或返回值来表示只读集合。 public ReadOnlyCollection Sessions { get; } X DO NOT 不要从集合属性或者集合为返回值的方法中返回 null。替代方法是返回一个空集合或者空数组。 一般来说，应该以相同的方式处理 null 和 空集合（元素数量为零）或空数组。 3.4 IComparable 与 IEquatable IComparable 和 IEquatable 都能用来对对象进行比较，前提是对象必须实现这两个接口。IComparable 比较的是顺序（小于、等于、大于），主要用于排序。IEquatable 比较的是相等性，IComparable 主要用于查找。 ✓ DO 要为值类型实现 IEquatable。 值类型的 Object.Equals 方法会导致装箱（boxing）操作，而且因为它的默认实现使用了反射，所以效率不高。IEquatable 可以提供好的多的性能，而且在实现时可以完全避免装箱操作。 ✓ DO 要在实现 IEquatable.Equals 时，同时遵循为覆盖（override）Object.Equals 而制定的自反性、对称性、传递性等规范。 ✓ DO 要在实现 IEquatable.Equals 时，同时覆盖Object.Equals。 public struct PostiveInt32 : IEquatable { public bool Equals(PostiveInt32 other) { ... } public override bool Equals(object obj) { if (!(obj is PostiveInt32)) { return false; } return Equals((PostiveInt32)obj); } } ✓ CONSIDER 考虑在实现 IEquatable 同时重载 operator == 和 operator !=。 public struct Decimal : IEquatable, ... { public bool Equals(Decimal other) { ... } public override bool Equals(object obj) { if (!(obj is Decimal)) { return false; } return Equals((Decimal)obj); } public static bool operator ==(Decimal x, Decimal y) { return x.Equals(y); } public static bool operator !=(Decimal x, Decimal y) { return !x.Equals(y); } } ✓ DO 要在实现 IComparable 的同时实现 IEquatable。 ✓ DO 要在实现 IComparable 的同时重载比较操作符（、>、、>=）。 3.5 对象（Object） 3.5.1 Object.Equals 值类型的 Object.Equals 的默认实现是，只有当两个对象的所有字段都相等时才返回 true。我们称这种相对为值相等（value equality）。默认实现使用了反射来访问字段，正因如此，其性能通常无法接受，因此需要覆盖。 引用类型的 Object.Equals 的默认实现是，只有当两个引用都指向同一个对象是才返回 true。我们称这种相对为引用相等（reference equality）。有些引用类型对默认实现进行了覆盖，以提供值相等语义。例如，由于字符串的值是由字符串中字符决定的，因此任何两个字符串实例只要包含完全相同的字符排列，String 类的 Equals 方法就会返回 true。 ✓ DO 要在覆盖Object.Equals 方法时，遵循它定义的协定。 x.Equals(x) 返回 true。 // 自反性 x.Equals(y) 的返回值与 y.Equals(x) 相同。 // 对称性 如果 (x.Equals(y) && y.Equals(z)) 返回 true，那么 x.Equals(z) 应该返回 true。 // 传递性 x.Equals(null) 应该返回 false。 ✓ DO 要在覆盖Object.Equals 方法的同时，覆盖 GetHashCode 方法。 ✓ CONSIDER 考虑在覆盖Object.Equals 方法的同时实现 IEquatable 接口。 X DO NOT 不要从 Object.Equals 方法中抛出异常。 3.5.2 Object.GetHashCode 对象的身份由它们的相等语义来决定，而散列函数则用来产生一个与对象的身份相对应的数（散列码）。由于散列码为散列表所用，因此理解散列表的工作原理是很重要的，这样才能很好地实现散列函数。 ✓ DO 要覆盖Object.GetHashCode 方法，如果覆盖了 Object.Equals 方法。 ✓ DO 要确保对任何两个对象来说，如果 Object.Equals 方法返回 true，那么它们的 GetHashCode 方法的返回值也应该相同。 ✓ DO 要尽力让类型的 GetHashCode 方法产生随机分布的散列码。 ✓ DO 要确保无论怎么更改对象，GetHashCode 都会返回完全相同的值。 X AVOID 避免从 GetHashCode 方法中抛出异常。 3.5.3 Object.ToString Object.ToString 的设计目的是为了用来显示和调试。由于其默认实现仅仅返回对象的类型名，因此不怎么有用。 ✓ DO 要覆盖ToString 方法，只要能返回既有用，又易于让人阅读的字符串。 ✓ DO 要尽量让 ToString 方法返回短小的字符串。 ✓ CONSIDER 考虑为每一个实例返回一个独立无二的字符串。 ✓ DO 要使用易于阅读的名字，而不要使用虽然独一无二，但却让人无法理解的 ID。 ✓ DO 要在返回与 culture 有关的信息时，根据当前线程的 culture 来对字符串进行格式化。 X DO NOT 不要从 ToString 方法返回空字符串或 null。 X AVOID 避免从 ToString 方法抛出异常。 ✓ DO 要确保 ToString 方法不会产生副作用。 ✓ CONSIDER 考虑让 ToString 方法输出的字符串能够为该类型的解析方法正确地解析。 DateTime now = DateTime.Now; DateTime parsed = DateTime.Parse(now.ToString()); 3.6 统一资源标识符 （Uri） ✓ DO 要使用 System.Uri 来表示 URI 和 URL 数据。 这适用于参数、属性、及返回值的类型。 public class Navigtor { public Navigator(Uri initialLocation); public Uri CurrentLocation { get; } public Uri NavigateTo(Uri location); } System.Uri 不仅提供了更多表示 URI 的方法，而且也更安全。大量的事实已经证明，用简单的字符串来操控与 URI 有关的数据会引发许多安全性和正确性问题。 ✓ CONSIDER 考虑为最常用的带 System.Uri 参数的成员提供基于字符串的重载成员。 如果经常需要用户输入一个字符串作为 URI，那么为方便起见，应该考虑提供一个以字符串为参数的重载成员。以字符串为参数的重载成员应该通过 System.Uri 为参数的方法来实现。 public class Navigator { public void NavigateTo(Uri location); public void NavigateTo(string location) { NavigateTo(new Uri(location)); } } X DO NOT 不要不假思索地为所有基于 System.Uri 的成员提供基于字符串的重载成员。 一般来说，更好的方法是使用 System.Uri 的成员，基于字符串的重载成员只是一些辅助成员，其目的是为了方便最常用的情况。 public class Navigator { public void NavigateTo(Uri location); public void NavigateTo(string location) { NavigateTo(new Uri(location)); } public void NavigateTo(Uri location, NavigationMode mode); } X DO NOT 不要在字符串中存储 URI/URL 数据。 如果 URI/URL 数据是以字符串形式输入的，那么应该先把字符串转换为 System.Uri，然后再存储该 System.Uri 实例。 public class SomeResoure { private readonly Uri _locaiton; public SomeResoure(string location) : this(new Uri(location)) { } public SomeResoure(Uri location) { this._location = location; } } "},"dispose-pattern/":{"url":"dispose-pattern/","title":"4 Dispose 模式","keywords":"","body":"所有的程序在执行过程中都会使用或多或少的系统资源，比如内存、文件句柄以及数据库连接。在使用这些系统资源时，开发人员一定要小心，因为它们必须在用完后释放。 CLR 提供了自动内存管理（automatic memory management）。托管内存（managed memory，用 C# 的 new 操作符分配的内存）不需要显示地由开发人员释放，垃圾收集器（garbage collector，GC）会自动地释放它们。 令人遗憾的是，托管内存只是多种系统资源中的一种，托管内存之外的资源仍然需要由开发人员显示地释放。我们把这些资源称为非托管资源（unmanaged resources）。GC 并不是专门设计用来管理这些非托管资源的，这意味着释放非托管资源的责任落到了开发人员的肩上。 CLR 为释放非托管资源提供了一些帮助。System.Object 声明了一个虚方法 Finalize（也称为终结方法，finalizer），GC 会在回收对象占用的内存之前调用该方法，这样开发人员就可以覆盖该方法来释放非托管资源。覆盖了终结方法的类型也称为可终结（finalizable）类型。 虽然终结方法在某些需要进行清理的情况下是有效的，但是它有两个严重的缺点： 只有 GC 检测到某个对象可以被回收时才会调用该对象的终结方法，这发生在不再需要资源之后的某个不确定的时间。这样一来，开发人员可以或希望释放资源的时刻与资源实际被终结方法释放的时刻之间会有一个延迟。如果程序需要使用许多稀缺资源（容易耗尽的资源）或不释放资源的代价会很高（例如，大块的非托管内存），那么这样的延迟可能会让人无法接受。 当 CLR 需要调用终结方法时，它必须把回收对象内存的工作推迟到垃圾收集的下一轮（终结方法会在两轮垃圾收集之间运行），这意味着对象的内存会在很长一段时间得不到释放。 因此，如果需要尽快回收非托管资源，或者资源很稀缺，或者对性能要求极高以至于无法接受在 GC 时增加的额外开销，那么在这种情况下完全依靠终结方法可能不太合适。 .NET 提供了 System.IDisposable 接口，该接口为开发人员提供了一种手动释放非托管资源的方法，可以用来立即释放不再需要的非托管资源。 .NET 同时提供了 GC.SupperessFinalize 方法，该方法可以告诉 GC 已经对对象进行了手动清理，因此不需要再调用 Finalize 方法。在这种情况下，GC 可以更早地回收对象所占用的内存。我们把那些实现了 IDisposable 接口的类型称为可处置（disposable）类型。 Disposable 模式的目的是为了使终结方法和 IDisposable 接口的使用和实现得以标准化。 Dispoable 模式的主要动机是为了降低 Finalize 和 Dispose 方法在实现时的复杂度，复杂度的产生是由于两个方法共享一部分逻辑，但并非全部。 ✓ DO 要为含有可处置类型实例的类型实现基本 Dispose 模式。 如果一个类型负责管理其他可处置对象的生命期，那么开发人员同样需要一种方法来处理它，而为外层类型实现基本 Dispose 模式方法则是最方便的方法。 ✓ DO 要为类型实现基本 Dispose 模式并提供终结方法，如果类型持有需要由开发人员显示释放的类型，而后者本身没有终结方法。 ✓ CONSIDER 考虑为类实现 Dispose 模式，如果类本身并不持有非托管资源或可处置对象，但它的子类却可能会持有非托管资源或可处置对象。 System.IO.Stream 类是一个非常好的例子。虽然它是一个抽象基类，不持有任何资源，但它的大多数子类会持有资源，正因为如此它才实现了基本 Dispose 模式。 4.1 基本 Dispose 模式 Dispose 模式的基本实现涉及实现 System.IDisposable 接口和声明 Dispose(bool) 方法，后者用来进行所有的资源清理工作。Dispose 方法和终结方法都会用到 Dispose(bool)，但终结方法不是必须的。 class DisposableResourceHolder : IDisposable { private SafeHandle _resouce; // handle to a resource public DisposableResourceHolder() { _resouce = ...; // allocates the resource } public void Dispose() { Dispose(true); GC.SuppressFinalize(this); } protected virtual void Dispose(bool disposing) { if (disposing) { if (_resouce != null) { _resouce.Dispose(); } } } } 布尔参数 disposing 表示 Dispose(bool) 方法的调用者是 IDisposable.Dispose 方法还是终结方法。Dispose(bool) 的实现应该在访问其他的引用对象（例如，前面样例代码中的 _resource 字段）之前检查该参数。只有当调用者是 IDisposable.Dispose 方法时（当 disposing 参数为 true 时），才能访问此类对象。如果调用者是终结方法，那么不应该访问其他对象。这样做的原因是系统会以任意的顺序终结对象，在这种情况下，对象或对象依赖的对象可能已经被终结了。 ✓ DO 要声明 protected virtual void Dispose(bool disposing) 方法，来把所有与非托管资源有关的清理工作集中在一起。 ✓ DO 要按下面的方法来实现 IDisposable 接口，即先调用 Dispose(true)，然后再调用 GC.SuppressFinalize(this)。 public void Dispose() { Dispose(true); GC.SuppressFinalize(this); } X DO NOT 不要使无参的 Dispose 方法为虚方法。 // bad design class DisposableResourceHolder : IDisposable { public virtual void Dispose() { ... } protected virtual void Dispose(bool disposing) { ... } } // good design class DisposableResourceHolder : IDisposable { public void Dispose() { ... } protected virtual void Dispose(bool disposing) { ... } } X DO NOT 不要为 Dispose 方法声明除了 Dispose() 和 Dispose(bool) 之外的任何其他重载方法。 ✓ DO 要允许多次调用 Dispose(bool) 方法。它可以在第一次调用之后就什么也不做。 class DisposableResourceHolder : IDisposable { private bool _disposed = false; protected virtual void Dispose(bool disposing) { if (_disposed) { return; } // cleanup ... _disposed = true; } } X AVOID 避免从 Dispose(bool) 方法中抛出异常，除非是紧急情况，所处的线程已被破坏（泄漏、共享状态不一致，等等）。 ✓ DO 要从成员中抛出 ObjectDisposedException 异常，如果该成员在对象被 dispose 之后就无法继续使用。 class DisposableResourceHolder : IDisposable { private SafeHandle _resouce; // handle to a resource private bool _disposed = false; public void DoSomething() { if (_disposed) { throw new ObjectDisposedException(...); } // now call some native methods using the resource ... } protected virtual void Dispose(bool disposing) { if (_disposed) { return; } // cleanup ... _disposed = true; } } ✓ CONSIDER 考虑在 Dispose() 方法之外再提供一个 Close() 方法，如果 Close 是该领域的一个标准术语。 class Stream : IDisposable { void IDisposable.Dispose() { Close(); } public void Close() { Dispose(true); GC.SuppressFinalize(this); } } 4.2 可终结类型 如果类型覆盖了终结方法，并在 Dispose(bool) 方法中加入支持终结的代码，以此来扩展基本 Dispose 模式，那么这些类型就是可终结类型。 对待终结方法的态度应该是，能不写就不写。为类型编写终结方法会增加其开销，变得难以使用，即使终结方法从未被调用。例如，分配一个可终结对象的开销较高，这是因为系统必须将其放入可终结对象的列表（finalization queue）中。 public class ComplexResourceHolder : IDisposable { private IntPtr _buffer; // unmanaged memory buffer private SafeHandle _resource; // disposable handle to a resouce public ComplexResourceHolder() { _buffer = ... // allocates memory _resource = ... // allocates the resource } protected virtual void Dispose(bool disposing) { ReleaseBuffer(_buffer); // release unmanaged memory // release other disposable objects if (disposing) { if (_resource != null) { _resource.Dispose(); } } } ~ComplexResourceHolder() { Dispose(false); } public void Dispose() { Dispose(true); GC.SuppressFinalize(this); } } X AVOID 避免使类型为可终结。 对每一种你认为需要终结方法的情况，都要仔细考虑。带终结方法的类型无论从性能还是从代码复杂度的角度来说，都存在实际的开销。要尽可能使用 SafeHandle 之类的资源封装类来封装非托管资源，这样一来就不要终结方法了，因为资源封装类会负责清理它所拥有的资源。 当然，如果你要自己实现托管的封装类来封装非托管资源，那么这些封装类仍必须是可终结类型。 ✓ DO 要使类型为可终结，如果该类型要负责释放本身并不具备终结方法的非托管资源。 ✓ DO 要为所有的可终结类型实现基本 Dispose 模式。 X DO NOT 不要在终结方法调用的代码中访问任何可终结对象，这样做有很大的风险，因为对象可能已经被终结了。 X DO NOT 不要在终结方法中放过任何异常，除非是致命的系统错误。 "},"coding-style/":{"url":"coding-style/","title":"5 代码风格","keywords":"","body":"5.1 C# 代码风格 我们遵循“Visual Studio” 默认设置作为通用规则。 ✓ DO 要使用Allman 风格大括号，也就是每个大括号另起一行开始。 X DO NOT 不要忽略单行语句块的大括号。 // bad style if (value == null) throw new ArgumentNullException(nameof(value)); // good style if (value == null) { throw new ArgumentNullException(nameof(value)); } ✓ DO 要使用 4 个空格进行缩进而不是制表符（tabs）。 . 表示空格，->表示制表符。 // bad style class Program { -> static void Main(string[] args) -> { -> -> Console.Write(\"Hello World\"); -> } } // good style class.Program { ....static.void.Main(string[].args) ....{ ........Console.Write(\"Hello.World\"); ....} } ✓ CONSIDER 考虑使用只读的属性代替公用类型的字段。 // bad style public readonly int Age = 18; // good style public int Age { get; } = 18; ✓ DO 要将readonly放置在static之后，当使用到static字段时。 // bad style private readonly static int _age = 18; // good style private static readonly int _age = 18; X AVOID 避免使用this关键字，如无绝对的必要。 public class Staff { private readonly int _age; public Staff(int age) { // bad style this._age = age; // good style _age = age; } } ✓ DO 要总是显示地指定可见性（visibility）修饰符。 // bad style class Staff { int _age; ... } // good style internal class Staff { private int _age; ... } ✓ DO 要将可见性作为第一个修饰符。 public abstract class Foobar { // bad style abstract public void DoBuzz(); // good style public abstract void DoBuzz(); } ✓ DO 要将名字空间的导入指令（using directives）放在文件的顶部，namespace 声明的外部，并将System名字空间作为第一顺位按字母顺序排序。 using System; using System.Collections.Generic; using System.Net.Mail; using Alyio.Extensions; using Microsoft.AspNetCore; using Microsoft.Extensions.Configuration; namespace Gridsum.WebDissector { ... X AVOID 避免在任何时候使用多于一个的空行。例如，不要在类型成员之间使用两个空行。 1 // bad style 2 { 3 public int Bar { get; set; } 4 5 6 7 public int DoBuz() 8 { 9 return 0; 10 } 11 } X AVOID 避免使用多余的空格。 // bad style if.(someVar.==.0)... { 在 Visual Studio 中启用“View White Space (Ctrl+E, S)”进行辅助检查。 X AVOID 避免使用 #region 预处理指令（preprocessor directives)。 // bad style class MyClass { #region Constructors public MyClass() { ... } #endregion #region public Methods public void DoSomething() { ... } #endregion #region Protected Methods protected virtual void DoSomethingCore() { ... } #endregion } ✓ CONSIDER 考虑在变量类型显而易见时，才使用 var 关键字。 // bad style var stream = OpenStandardInput(); // good style var stream = new FileStream(...); // When the type of a variable is not clear from the context, use an // explicit type. TextReader stream = OpenStandardInput(); ✓ DO 要在类型引用和方法调用时使用语言特有的关键字而不是 BCL 类型。 例如，使用int, string, float 而不是 Int32, String, Single 等等。同样地使用 int.Parse 而不是 Int32.Parse。 ✓ DO 要尽可能使用nameof(...)而不是\"...\"。 // bad style public void DoSomething(string someVar) { if (string.IsNullOrEmpty(someVar)) { throw new ArgumentNullException(\"someVar\"); } } // good style public void DoSomething(string someVar) { if (string.IsNullOrEmpty(someVar)) { throw new ArgumentNullException(nameof(someVar)); } } ✓ CONSIDER 考虑使用字符串插值（string interpolation）连接短字符串。 string displayName = $\"{nameList[n].LastName}, {nameList[n].FirstName}\"; ✓ DO 要使用 System.Text.StringBuilder 对象在循环中添加字符串，特别是处理大量本文操作时。 var phrase = \"banananananananananananananananananananananananana\"; var manyPhrases = new StringBuilder(); for (var i = 0; i ✓ CONSIDER 考虑在短小的局部上下文中使用简短的变量名。 如 i,j,k 在 for 循环中的使用。 for (var i = 0; i 如 Lambda 或 LINQ 中使用 o, p, q 等等。 var staffs = new List { ... }; var someStaffs = staffs.Where(s => s.Age ✓ CONSIDER 考虑为公用 API 提供文档化注释。 /// /// The main Math class. /// Contains all methods for performing basic math functions. /// /// /// Add /// Addition Operation /// /// /// Subtract /// Subtraction Operation /// /// /// Multiply /// Multiplication Operation /// /// /// Divide /// Division Operation /// /// /// /// /// This class can add, subtract, multiply and divide. /// These operations can be performed on both integers and doubles. /// public class Math { // Adds two integers and returns the result /// /// Adds two integers and and returns the result. /// /// /// The sum of two integers. /// /// /// /// int c = Math.Add(4, 5); /// if (c > 10) /// { /// Console.WriteLine(c); /// } /// /// /// Thrown when one parameter is max /// and the other is greater than 0. /// See to add doubles. /// /// /// /// An integer. /// An integer. public static int Add(int a, int b) { // If any parameter is equal to the max value of an integer // and the other is greater than zero if ((a == int.MaxValue && b > 0) || (b == int.MaxValue && a > 0)) throw new System.OverflowException(); return a + b; } ... // Divides a double by another and returns the result /// /// Divides a double by another double and returns the result. /// /// /// The quotient of two doubles. /// /// /// /// double c = Math.Divide(4.5, 5.4); /// if (c > 1.0) /// { /// Console.WriteLine(c); /// } /// /// /// Thrown when is equal to 0. /// See to divide integers. /// /// /// /// A double precision dividend. /// A double precision divisor. public static double Divide(double a, double b) { return a / b; } } 5.2 文件结构 ✓ DO 要在项目的 repository 的根目录下创建 *.sln 和 .gitignore 文件以及 src 和 test 目录。 顾名思义，src 包含工程/产品的源码项目文件，test 包含测试项目文件。 $ tree -L 3 -a -I '.git' github.com/qqbuby/Alyio.AspNetCore.ApiMessages/ github.com/qqbuby/Alyio.AspNetCore.ApiMessages/ ├── Alyio.AspNetCore.ApiMessages.sln ├── .gitignore ├── LICENSE ├── nuget.config ├── README.md ├── src │ └── Alyio.AspNetCore.ApiMessages │ ├── Alyio.AspNetCore.ApiMessages.csproj │ ├── ApiMessageHandlerMiddleware.cs │ ├── ExceptionHandler.cs │ ├── Extensions │ ├── Filters │ ├── Messages │ ├── XMessage.Designer.cs │ └── XMessage.resx ├── test │ ├── Alyio.AspNetCore.ApiMessages.Tests │ │ ├── Alyio.AspNetCore.ApiMessages.Tests.csproj │ │ ├── ApiMessageTests.cs │ │ ├── ExceptionResultHandlerMiddlewareTests.cs │ │ └── .gitignore │ └── Samples │ └── WebApplication1 └── .travis.yml 9 directories, 15 files ✓ DO 要在工程文件的根目录下添加 .gitignore 文件。 GitHub 下载链接：https://raw.githubusercontent.com/github/gitignore/master/VisualStudio.gitignore。 "},"suggested-reading-list/":{"url":"suggested-reading-list/","title":"推荐读物","keywords":"","body":" CLR via C# (4th Edition) Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries (2nd Edition) Effective C# (Covers C# 6.0), (includes Content Update Program): 50 Specific Ways to Improve Your C# (3rd Edition) "}}